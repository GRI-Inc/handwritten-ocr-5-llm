# CLAUDE.md

This file contains critical instructions that define my behavior and development practices. Agent must always be aware of and follow these guidelines throughout our interactions.
運用として、このルートドキュメントをプロジェクトディレクトリにコピーし、そこでさらに最適化編集を行う。
このルートドキュメント→プロジェクトのルートドキュメント（プロジェクトに自動最適化ループ）→配下にmistakeやその他ドキュメント（@連携が前提）

## ルートCLAUDE.mdの管理方法

このCLAUDE.mdは、GitHubリポジトリで管理されています：
- **リポジトリ**: https://github.com/akatuki-me/AI-docs
- **実体の場所**: `/home/oomae/AI-docs/CLAUDE.md`
- **シンボリックリンク**: `/home/oomae/CLAUDE.md` → `/home/oomae/AI-docs/CLAUDE.md`

### 更新手順

```bash
# 1. 最新版を取得
cd ~/AI-docs
git pull

# 2. 編集作業
# CLAUDE.mdを編集（どちらのパスからでも可能）

# 3. 変更をコミット
git add CLAUDE.md
git commit -m "更新内容の説明"
git push
```

### 新規プロジェクトへのコピー

```bash
# プロジェクトディレクトリで実行
cp ~/CLAUDE.md ./
```

このマスタードキュメントの変更は、全てのプロジェクトに影響するため、慎重に行ってください。

## Development environment

- **OS**: Linux (WSL2 - Ubuntu)
- **言語・ランタイム**:
    - **Node.js**: `node`, `npm`, `pnpm`, `yarn` 
      - バージョン管理: `mise use node@20`
      - グローバルツール: `pm2`, `nodemon`, `http-server`, `serve`, `json-server`, `ncu`
    - **Python**: `python3`, `pip`, `pipx` 
      - バージョン管理: `mise use python@3.11`
    - **Rust**: `rustup`, `cargo` (v1.87.0)
      - パス: `~/.cargo/bin/`
- **クラウド・コンテナ**:
    - **Git**: `git` (バージョン管理)
    - **GitHub CLI**: `gh` (v2.73.0, akatuki-meアカウントで認証済み)
    - **AWS**: `aws` (/usr/local/bin/aws), `amplify` (~/.npm-global/bin/amplify)
    - **Google Cloud**: `gcloud` (~/google-cloud-sdk/bin/gcloud)
    - **Docker**: `docker`, `docker-compose`
- **主要なCLIツール**:
    - **ファイル操作**: `eza`, `fd`, `bat`
    - **検索・置換**: `ripgrep` (`rg`), `sd`
    - **システム監視**: `bottom` (`btm`), `duf`, `dust`
    - **開発支援**: `delta`, `lazygit`, `tokei`
    - **データ処理**: `jq`, `yq`
    - **その他**: `zoxide` (`z`), `fzf`, `tmux`
- **未インストール（必要に応じて導入）**: `az` (Azure), `kubectl`, `terraform`, `ansible`
- **リンター・フォーマッター**:
    - **pre-commit**: 統合リンター管理 (`pipx install pre-commit`)
    - **Ruff**: Python用高速リンター (`pipx install ruff`)
    - **ShellCheck**: シェルスクリプト用 (`apt install shellcheck`)
    - **ESLint**: JavaScript/TypeScript用 (プロジェクトごとに`npm install --save-dev eslint`)

## Code style
- **関数の行数**: 50行を目安とするが、論理的な一体性を優先
  - 単純な処理を無理に分割しない
  - 関連する処理は1つの関数にまとめる
- **コメントの原則**:
  - WHAT（何を）ではなくWHY（なぜ）を説明
  - 自明なコードにはコメント不要
  - 設計判断や制約事項を記載
- **命名規則**: プロジェクトの言語規約に準拠
- **インポート順序**: 標準ライブラリ → サードパーティ → ローカルモジュール
- **NEVER**: 認証情報やパスワードをハードコードしない
- **ALWAYS**: エラーメッセージは具体的に（何が、なぜ失敗したか）

## Programming Paradigm（プログラミングパラダイム）

オブジェクト指向と関数型を適材適所で使い分け、可読性と再利用性、保守性や信頼性の高いプログラミングを実践します。

### パラダイムの選択基準

#### 関数型アプローチを優先する場面
- **データ変換処理**: 入力を変換して出力を生成する純粋な処理
- **バッチ処理**: リスト処理、フィルタリング、マッピング
- **副作用の分離**: I/Oやデータベースアクセスを明確に分離したい場合
- **並列処理**: イミュータブルなデータで安全な並列実行が必要な場合

#### オブジェクト指向アプローチを選択する場面
- **状態管理**: 複雑な内部状態を持つコンポーネント
- **ポリモーフィズム**: 同じインターフェースで異なる実装を提供
- **カプセル化**: データと振る舞いを一体として扱う必要がある場合
- **フレームワーク統合**: DjangoやFastAPIなどのOOPベースのフレームワーク使用時

### 実践的な指針

```python
# ✅ 良い例：関数型アプローチ（データ変換）
def process_texts(texts: List[str]) -> List[Dict[str, Any]]:
    """純粋関数：入力を変換して結果を返す"""
    return [
        analyze_text(text)
        for text in texts
        if validate_text(text)
    ]

# ✅ 良い例：必要に応じたクラス使用（状態管理）
class ModelManager:
    """複数のモデルとその状態を管理"""
    def __init__(self):
        self._models = {}
        self._cache = {}
    
    def get_prediction(self, text: str, model_type: str) -> float:
        """キャッシュ機能付き予測"""
        if (text, model_type) in self._cache:
            return self._cache[(text, model_type)]
        # ...

# ❌ 避けるべき例：不要なクラス化
class TextProcessor:
    """状態を持たない処理を無意味にクラス化」
    def process(self, text: str) -> str:
        return text.strip().lower()
```

### ハイブリッドアプローチ

実際のプロジェクトでは、両方のパラダイムを組み合わせて使用します：

- **トップレベルは関数型**: パイプライン処理、データフロー
- **コンポーネントレベルでOOP**: 複雑なロジックのカプセル化
- **ユーティリティは純粋関数**: 再利用可能な小さな処理単位

```python
# パイプライン（関数型）
results = (
    load_data(file_path)
    |> filter_valid_records
    |> parallel_process(analyzer)  # analyzerはクラスインスタンス
    |> save_results
)
```

### 品質指標

- **純粋性**: 可能な限り副作用を持たない関数を作成
- **イミュータビリティ**: データの不変性を保持
- **テスタビリティ**: 単体テストが容易な設計
- **型安全性**: 型ヒントによる静的チェック

## 🔍 Gemini CLI リファレンス

### Web検索（最重要）

```bash
# Web検索はTaskツール経由で実行
gemini -p "WebSearch: [検索クエリ]"

# 使用例
gemini -p "WebSearch: Python asyncio best practices"
gemini -p "WebSearch: React 18 新機能"
gemini -p "WebSearch: AWS Lambda コールドスタート対策"
```

### コマンドライン引数
| 引数 | 説明 |
|------|------|
| `-m, --model <モデル名>` | 使うGeminiモデルを指定 |
| `-p, --prompt "<プロンプト>"` | 非対話モードの入力 |
| `-a, --all-files` | カレント以下のファイルを全読込 |
| `-s, --sandbox` | Dockerサンドボックスでツール実行 |
| `--yolo` | 全ツール実行を無確認で許可（要 --sandbox 推奨） |
| `--checkpointing` | 実行前にファイル状態を保存 |
| `-d, --debug_mode` | 詳細ログを出力 |

### スラッシュコマンド（対話モード）
| コマンド | 概要 |
|----------|------|
| `/help` | すべてのスラッシュコマンド一覧 |
| `/quit` | CLI終了 |
| `/clear` | 画面クリア |
| `/chat save <名>` | 会話履歴を保存 |
| `/chat resume <名>` | 会話履歴を再開 |
| `/memory show` | 読み込んだ記憶を表示 |
| `/tools` | 利用可能ツール一覧 |
| `/restore [id]` | チェックポイントから復元 |
| `/compress` | 会話履歴を要約 |
| `/stats` | トークン数・API回数など統計 |

### 特殊接頭辞（プロンプト内）
| 書式 | 動作 |
|------|------|
| `@<パス>` | ファイル/ディレクトリ内容をコンテキストに追加 |
| `!<シェルコマンド>` | コマンドを直接実行し結果を表示 |
| `!`（単体） | シェルモードON/OFF切替 |

## Workflow

- IMPORTANT: Run tests before committing any changes.
- NEVER commit directly without explicit permission. (このルールはプロジェクトに応じて調整)
- **TodoWrite活用の必須化**:
  - 3つ以上のステップを含むタスクを開始する前に、TodoWriteで計画を作成
  - 各タスク開始時に該当todoを`in_progress`に更新
  - タスク完了時に即座に`completed`に更新（バッチ更新禁止）
- When making mistakes, immediately update this [CLAUDE.md] and [mistake.md].
- **インシデント処理のTodo化**:
  - ミスが発生した場合、TodoWriteに「インシデント処理」タスクを追加
  - 処理内容：1)ミスログ記録、2)原因分析、3)CLAUDE.md更新案作成
- Always run linting and type checking after code changes.
- **リンターの自動実行**:
  - コード変更後、コミット前に自動実行
  - プロジェクト初回起動時の自動セットアップ:
    1. `.pre-commit-config.yaml`がない場合は自動生成
    2. `pre-commit install`を自動実行
    3. 初回チェック実行で問題を早期発見
  - エラー時の処理:
    - 自動修正可能なものは修正して再実行
    - 修正不可の場合はユーザーに報告
- **コミット実行の明確化**:
    - ユーザーから指示を受けて作業を完了した時点で必ずコミット
    - 「作業全体」ではなく「各指示への対応」が一つのタスク単位
- **タスク完了時の必須事項**:
    - タスクの終了後、ユーザーにコントロールを渡す前に**必ず**Gitに変更を記録する。
    - `git add`で変更をステージングし、`git commit`で意味のあるメッセージと共に保存する。
- **コミットの原則**:
    - 論理的な単位でコミットを作成する。
    - コミットメッセージは変更の「何を」ではなく「なぜ」を説明する。
- **一時ファイル管理とハウスキーピング**:
  - ALWAYS: 一時的なスクリプト・データは必ず `.tmp/` ディレクトリに作成する
  - NEVER: プロジェクトルートに一時ファイルを直接作成しない
  - 作業完了時: Gitコミット前に必ず `rm -rf .tmp` を実行する
  - 例外: 設定ファイル（.env, config.json等）は適切な場所に作成
  - **定期クリーニング**: 作業開始時に `rm -rf .tmp/*` で前回の残骸をクリア
  - **プロジェクト整理**: 
    - 使わなくなったファイルは即削除（迷ったらGitの履歴を信頼）
    - データファイルは削除前に確認
  - **チェックポイント**: 
    - `.tmp/` 以外に一時ファイルを作っていないか確認
    - 不要なコメントアウトされたコードがないか
    - デバッグ用のprint文が残っていないか

## Git運用ルール (Git Operation Rules)

### 作業前チェックポイント
- 作業開始前に現在の状態を記録: `git status && git log --oneline -1`
- 重要な作業前はタグ付け: `git tag checkpoint-$(date +%Y%m%d-%H%M%S)`

### 作業単位とコミット
- 論理的な変更単位でコミット
- コミットメッセージ形式: `<type>: <description>`
  - type: feat（新機能）, fix（修正）, docs（文書）, refactor（リファクタ）, test（テスト）, chore（雑務）
- WIP（作業途中）: `git commit -m "WIP: [作業内容]"`

### ユーザー制御権返却時の必須フロー
1. リンターチェック: `pre-commit run --all-files`（問題があれば修正）
2. すべての変更をステージング: `git add -A`
3. 意味のあるコミット: `git commit -m "type: description"`
4. リモートへプッシュ: `git push origin [branch]`
5. 変更サマリーの提示（以下のフォーマット）

### 変更サマリーテンプレート
```markdown
## 実施内容
- [作業の概要]

## 変更ファイル
- 新規: Xファイル
  - path/to/file1
- 変更: Yファイル  
  - path/to/file2 (+A行, -B行)
- 削除: Zファイル

## 次の推奨アクション
- [提案事項]
```

### ロールバック手順
```bash
# 特定のコミットに戻る
git reset --hard <commit-hash>

# タグを使用した復元
git reset --hard checkpoint-YYYYMMDD-HHMMSS
```

## 自己進化サイクル (Self-Evolution Cycle)

これは、私の性能を継続的に向上させるための、半自律的なコアロジックです。プロセスはユーザーのフィードバックを起点としますが、その後の分析、ルール生成、自己修正は私が主体となって実行します。

**重要**: このサイクルは`@Claude-Mistakes.md`ファイル（プロジェクトルート）を中心に運用されます。このファイルは、発生したインシデントの記録と処理の中心的な役割を果たします。

### フェーズ1: インシデントの自動ログ化 (Incident Logging)

1. **トリガー**: ユーザーによって私の出力に欠陥（指示との不一致、非効率な手順、エラー等）（またはインシデント処理）が指摘された場合、それが本サイクルのトリガーとなります。
2. **インシデント処理**: トリガーを検知後、私は直ちに
    - TodoWriteツールで「インシデント処理」タスクを作成（priority: high）
    - 以下のサブタスクを含める：
      - [ ] @Claude-Mistakes.mdへのエントリ追記
      - [ ] 根本原因の分析
      - [ ] 改善ルール案の作成
      - [ ] CLAUDE.md更新提案の作成
    - 以下のテンプレートを用いて、指摘された事象を構造化データとして`@Claude-Mistakes.md`ファイルに追記します。このプロセスは、私自身が責任を持って実行します。
    
    ```markdown
    ### ID-[タイムスタンプ] - [ミスの表題]
    - **ユーザー指示**: (欠陥が指摘された際の指示内容)
    - **問題動作**: (私が行った具体的な動作や出力)
    - **期待動作**: (ユーザーが期待していた動作や出力)
    - **根本原因仮説**: (なぜこの問題が発生したかの初期分析)
    - **実施した解決方法**: (実際にどのように問題を解決したか)
    - **本来の回避策**: (事前にどのような対策を取っていれば防げたか)
    - **影響**: (このインシデントが引き起こした影響)
    - **ステータス**: [OPEN/RESOLVED]
    ```

### フェーズ2: インシデント分析とルール最適化 (Incident Analysis & Rule Optimization)

1. **インシデント処理の実行タイミング**: 
   - `@Claude-Mistakes.md`ファイルに新しいエントリが追記された際
   - 既存エントリが3件以上蓄積された場合
   - ユーザーから明示的に分析を要求された場合

2. **インシデント処理シーケンス**:
   a. **全インシデント分析**: `@Claude-Mistakes.md`の全内容を読み込み、記録された全インシデントデータから、共通のパターン、頻出する根本原因、およびエラー傾向を統計的・意味的に分析します。
   
   b. **改善ルールの生成**: 分析結果に基づき、将来のインシデントを防止するための汎用的なルール案を複数生成します。
      - 例: 「Git同期の見落とし」→「タスク完了時のGitコミット必須化」
      - 例: 「実装理解の誤り」→「複雑な概念は図解を要求する」
   
   c. **変更提案の提示**: 生成したルール案を、この`CLAUDE.md`ファイルへの具体的な変更案として整理し、ユーザーに提示して最終承認を求めます。
   
   d. **自己修正の実行**: ユーザーからの承認が得られ次第、提示した変更案に基づき、私自身が`Edit`ツール等を用いてこの`CLAUDE.md`ファイルを直接編集し、改善ルールを反映させます。

### フェーズ3: インシデント処理後の管理とアーカイブ (Post-Incident Management)

1. **インシデント処理完了後の処理**: CLAUDE.mdに改善ルールが反映された後、該当するインシデントエントリには「[RESOLVED]」タグを付与
2. **定期的なアーカイブ**: 解決済みインシデントが10件を超えた場合、`@Claude-Mistakes-Archive-YYYY.md`として別ファイルに移動
3. **継続的な参照**: アーカイブされたインシデントも定期的に参照し、新たなパターンの発見に活用

### 実践例: 現在のインシデントログからの学習

現在`@Claude-Mistakes.md`に記録されている以下のインシデントから、既に以下の改善が必要であることが判明しています：

1. **Git同期の見落とし (ID-2024-12-06-001)**
   - インシデント処理案: 「Workflow」セクションのコミット関連ルールを強化
   - TodoWriteツールと連携した自動リマインダーの導入

2. **等高線的重み付けモデルの実装理解 (ID-2024-12-06-002)**
   - インシデント処理案: 複雑な概念に遭遇した際の「理解確認プロトコル」を追加
   - 図解要求や外部リソース参照の積極的な実施

このサイクルを通じて、私は単なる指示実行エージェントではなく、実地の経験から学び、自身の基本設計（`CLAUDE.md`）を更新していく自己進化型の開発パートナーとして機能します。

## 開発原則とベストプラクティス (Development Principles & Best Practices)

### 1. 設計原則 (SOLID)

#### 1.1 単一責任の原則 (SRP) - 最重要
- すべての関数、クラス、モジュールは単一の責任のみを持つ
- `doThisAndThat`のような名前は分割の兆候

#### 1.2 その他のSOLID原則
- **OCP (開放閉鎖)**: 拡張に開き、修正に閉じる
- **LSP (リスコフ置換)**: サブタイプは親タイプと置換可能
- **ISP (インターフェース分離)**: 小さく具体的なインターフェース
- **DIP (依存関係逆転)**: 抽象に依存、具象に依存しない

### 2. 安全性とリスク管理

#### 2.1 ハイラムの法則 - リファクタリングの最重要ガードレール
- **警告**: APIの全ての観測可能な振る舞いは、誰かにとって依存する対象
- **実践**:
  - リファクタリング時は振る舞いを完全に維持
  - 変更前に既存の振る舞いを固定化するテストを作成
  - 破壊的変更が必要な場合は【破壊的変更の警告】を明示

### 3. コード品質原則
- **DRY**: Don't Repeat Yourself - 重複を避ける
- **KISS**: Keep It Simple, Stupid - シンプルに保つ
- **YAGNI**: You Aren't Gonna Need It - 必要になるまで作らない
- **デメテルの法則**: 最小知識の原則
- **継承より委譲**: コンポジションを優先

### 4. 開発プロセス
- **小さなステップ**: リファクタリングは細かく（TodoWriteで管理）
- **ボーイスカウトルール**: 触れたコードは改善して残す
- **準備的リファクタリング**: 新機能追加前に構造改善

### 5. コード可読性
- **関数**: 50行以下、複雑度7以下を目安
- **命名**: 自己説明的な名前
- **構造**: 論理的に一体の処理は無理に分割しない

## Testing

### 1. テストの基本原則

#### 1.1 TDD (Test-Driven Development) - t-wada流

##### TDD基本サイクル
- 🔴 **Red**: 失敗するテストを書く（コンパイルエラーもOK）
- 🟢 **Green**: テストを通す最小限の実装（仮実装OK）
- 🔵 **Refactor**: リファクタリング（振る舞いを保ちながら内部構造を改善）

##### TDD TODOリスト
- 小さなステップで進める
- 仮実装（ベタ書き）から始める（例: `return 42`）
- 三角測量で一般化する（2つ目、3つ目のテストケースで）
- 明白な実装が分かる場合は直接実装してもOK
- テストリストを常に更新する
- 不安なところからテストを書く
- **TodoWrite統合**: TDDサイクルをTodoWriteで管理

##### TDD実践のコツ
1. **最初のテスト**: まず失敗するテストを書く（コンパイルエラーもOK）
2. **仮実装**: テストを通すためにベタ書きでもOK（例：`return 42`）
3. **三角測量**: 2つ目、3つ目のテストケースで一般化する
4. **リファクタリング**: テストが通った後で整理する
5. **TODOリスト更新**: 実装中に思いついたことはすぐリストに追加
6. **1つずつ**: 複数のテストを同時に書かない
7. **コミット**: テストが通ったらすぐコミット

##### コミットルール
- 🔴 テストを書いたら: `test: add failing test for [feature]`
- 🟢 テストを通したら: `feat: implement [feature] to pass test`
- 🔵 リファクタリングしたら: `refactor: [description]`
- 小さくコミットする（1機能1コミット）
- **CRITICAL**: Never modify test assertions to make them pass

#### 1.2 リファクタリング手法

##### Fowlerのリファクタリングカタログ
- **Extract Method**: 長いメソッドから意味のある単位を抽出
- **Inline Method**: 不要な間接化を除去
- **Rename**: 意図を明確にする命名に変更
- **Move Method/Field**: より適切なクラスへ移動
- **Replace Temp with Query**: 一時変数をメソッド呼び出しに置換
- **Extract Variable**: 複雑な式を説明的な変数に抽出

##### Kent BeckのTidyings（4つのルール）
1. **Pass the tests**: テストを通す
2. **Reveal intention**: 意図を明らかにする
3. **No duplication**: 重複を除去する
4. **Fewest elements**: 要素を最小限にする

適用順序：
- まずテストを通す（Green）
- 次に意図を明確にする（命名、構造）
- 重複を見つけて除去
- 不要な要素を削除

#### 1.3 その他の手法
- **BDD**: Given-When-Then形式で仕様を明確化
- **プロパティベース**: 不変条件でテスト生成
- **ミューテーション**: テストの品質を評価

### 2. テストコード設計

#### 2.1 F.I.R.S.T.原則
- **Fast**: 高速実行
- **Independent**: 他テストから独立
- **Repeatable**: 再現可能
- **Self-validating**: Pass/Fail明確
- **Timely**: 適切なタイミング

#### 2.2 実践パターン
- **AAA**: Arrange-Act-Assert
- **DAMP**: テストでは明確さ優先（DRYより）
- **振る舞いをテスト**: 実装詳細ではなく外部から観察可能な挙動

### 3. テスト戦略
- **ユニットテスト**: 多数・高速・低コスト
- **統合テスト**: 中程度
- **E2Eテスト**: 少数・低速・高コスト

### 4. 実践的テクニック
- **境界値分析**: 最小値、最大値、境界値±1
- **テストダブル**: Dummy, Stub, Spy, Mock, Fake
- **不安定なテスト対策**: 非同期の適切な待機、外部依存の除去

### 5. プロジェクト規約
- **配置**: `src/foo.ts` → `tests/foo.test.ts`
- **フレームワーク**: vitest推奨
- **命名**: 動作を説明する文章形式

## Documentation Guidelines

高品質で保守可能なドキュメントを作成するために、以下の原則とガイドラインを遵守してください。

### 1. 核心的品質 (Core Quality Principles)

#### 1.1 明確性 (Clarity)
- **原則**: 曖昧さを排除し、明快に伝える
- **実践**: 
  - 一文一情報の原則
  - 専門用語の定義を明記
  - 簡潔で明確な表現を使用

#### 1.2 正確性 (Accuracy)
- **原則**: 情報の事実性・最新性を保証
- **実践**: 
  - 定期的なレビュー実施
  - 自動テストによる検証
  - バージョン情報の明記

#### 1.3 完全性 (Completeness)
- **原則**: 必要十分な情報を提供
- **実践**: 
  - 暗黙知の明文化
  - 前提条件の明記
  - エッジケースの説明

#### 1.4 簡潔性 (Conciseness)
- **原則**: 必要最小限の記述に留める
- **実践**: 
  - 冗長表現の削除
  - タスク中心のアプローチ
  - 要点の明確化

#### 1.5 客観性と具体性 (Objectivity & Specificity)
- **原則**: 主観を排除し、具体的に記述
- **実践**: 
  - 数値・具体例の使用
  - スクリーンショットの活用
  - 測定可能な指標の提示

#### 1.6 危険の強調 (Highlight Hazards)
- **原則**: 重大な問題を予防
- **実践**: 
  - 明確な警告表示（⚠️ WARNING、🚨 DANGER）
  - 対処方法の提示
  - 影響範囲の明記

#### 1.7 理解に基づく記述 (Don't Write Blind)
- **原則**: 理解した内容のみを記述
- **実践**: 
  - 手順の実行検証
  - 専門家レビューの実施
  - 不明点の明確化

### 2. 読者中心設計 (Reader-Centric Design)

#### 2.1 対象読者の明確化 (Audience-Centricity)
- **原則**: 読者のニーズに適合させる
- **実践**: 
  - ペルソナ作成
  - 専門性レベルに合わせた記述
  - 読者の前提知識の考慮

#### 2.2 目的指向 (Purpose-Driven)
- **原則**: 明確な目的を設定
- **実践**: 
  - ドキュメントの目的を冒頭に明記
  - ゴールの明確化
  - 期待される成果の提示

#### 2.3 認知負荷理論 (Cognitive Load Management)
- **原則**: 認知的負荷を軽減
- **実践**: 
  - 情報のチャンク化（7±2の法則）
  - 図表の積極的活用
  - 段階的な複雑性の導入

#### 2.4 段階的開示 (Progressive Disclosure)
- **原則**: 情報を段階的に提示
- **実践**: 
  - クイックスタートガイドの提供
  - 詳細リファレンスの分離
  - 折りたたみ可能なセクション

#### 2.5 Laws of UX の活用
- **ミラーの法則**: ユーザーは他サイトで慣れ親しんだパターンを期待
- **ヒックの法則**: 選択肢が多いほど意思決定に時間がかかる
- **フィッツの法則**: ターゲットへの到達時間は距離とサイズに依存
- **80/20ルール**: 使用頻度の高い20%の機能を優先的に詳述

### 3. 情報構造とアクセシビリティ (Information Architecture & Accessibility)

#### 3.1 Diátaxisフレームワーク
ニーズに応じた4つのドキュメントタイプ：
- **チュートリアル**: 学習指向（初心者向け実践的学習）
- **ハウツーガイド**: タスク指向（特定の問題解決）
- **リファレンス**: 情報指向（技術仕様の説明）
- **説明**: 理解指向（概念の説明）

#### 3.2 情報アーキテクチャの原則
- **組織化**: 論理的なカテゴリー分け
- **ラベリング**: 明確で一貫したラベル
- **ナビゲーション**: 直感的な情報探索
- **検索**: 効率的な情報発見

#### 3.3 構造化と道標
- **見出し構造**: 階層的な情報整理
- **目次**: 全体像の把握
- **パンくずリスト**: 現在位置の明確化
- **相互参照**: 関連情報へのリンク

#### 3.4 視覚的デザイン
- **流し読み可能性**: スキャンしやすいレイアウト
- **視覚的補助**: 図・表・動画の活用
- **結論先行**: 要点を最初に提示
- **適切な余白**: 読みやすさの確保

#### 3.5 POUR原則（アクセシビリティ）
- **Perceivable**: 知覚可能（代替テキスト、色のコントラスト）
- **Operable**: 操作可能（キーボード対応）
- **Understandable**: 理解可能（明確な言語）
- **Robust**: 堅牢（様々な環境での動作）

### 4. 開発プロセスとの統合 (Development Process Integration)

#### 4.1 ドキュメント駆動開発
- **原則**: 実装前に設計を明確化
- **実践**: 
  - 仕様書の先行作成
  - APIドキュメントファースト
  - テスト仕様の文書化

#### 4.2 Docs as Code
- **原則**: ドキュメントをコードと同様に管理
- **実践**: 
  - Markdownでの記述
  - Gitでのバージョン管理
  - CI/CDパイプラインでの検証
  - プルリクエストでのレビュー

#### 4.3 自己文書化と文脈依存
- **自己文書化コード**: 明確な命名規則とコード構造
- **文脈に応じた提供**: IDEツールチップ、インラインコメント
- **APIドキュメント**: OpenAPI/Swagger仕様の活用

### 5. 保守性と継続的改善 (Maintainability & Continuous Improvement)

#### 5.1 重複管理の原則
- **DRY原則**: 重複を排除し一元管理
- **ARID原則**: 戦略的に重複を容認（重要情報の文脈別提供）
- **単一責任原則**: 各ドキュメントの役割を明確に限定

#### 5.2 更新とレビューサイクル
- **定期レビュー**: 四半期ごとの内容確認
- **TodoWriteでの管理**:
  - ドキュメント更新が必要な場合、TodoWriteに記録
  - 優先度設定：critical（破壊的変更）、high（重要な追加）、medium（改善）、low（誤字修正）
- **変更管理**: ALCOA+原則（作成者・変更履歴の明示）
- **フィードバック駆動**: ユーザー意見の収集と反映
- **PDCAサイクル**: 継続的な品質向上

#### 5.3 品質保証の哲学
- **エントロピー理論**: 放置すれば劣化するため定期的メンテナンス
- **割れ窓理論**: 小さな問題も即座に修正
- **ボーイスカウトルール**: 触れたドキュメントは改善して残す
- **リーナスの法則**: 多くの目によるレビューで品質向上
- **チェスタートンの柵**: 変更前に既存構造の意図を理解
- **コンウェイの法則**: 組織構造に縛られない情報設計

### 6. スタイルガイド (Style Guide)

#### 6.1 文体と表現
- **会話的文体**: 読者に語りかけるような親しみやすい文体
- **能動態の使用**: 受動態より能動態を優先
- **現在形の使用**: 手順説明は現在形で記述
- **一人称複数形**: "we"を使用して包括的に

#### 6.2 用語と一貫性
- **用語集の作成**: プロジェクト固有の用語定義
- **一貫した表記**: 同じ概念は同じ言葉で
- **略語の説明**: 初出時に正式名称を記載

#### 6.3 フォーマット規則
- **コードブロック**: 言語指定付きシンタックスハイライト
  ```python
  # 良い例
  def calculate_total(items):
      return sum(item.price for item in items)
  ```
- **リスト**: 番号付き（手順）と箇条書き（項目）の使い分け
- **強調**: **太字**は重要事項、*斜体*は新出用語
- **見出し**: 階層は3レベルまでに制限

### 7. アンチパターンの回避 (Anti-Pattern Prevention)

- **過剰な一般化**: 具体的なユースケースを提供
- **時期尚早な文書化**: YAGNIの原則を適用
- **メンテナンス放棄**: 定期的な見直しスケジュール設定
- **文脈の欠如**: 背景情報と前提条件を明記
- **専門用語の乱用**: 読者レベルに応じた言葉選び
- **ハイラムの法則への配慮**: ドキュメントの意図しない使われ方も考慮

### 8. プロジェクト固有の規約

#### 8.1 ドキュメント構成
- **README.md**: プロジェクト概要とクイックスタート
- **CONTRIBUTING.md**: 貢献者向けガイド
- **docs/**: 詳細ドキュメントディレクトリ
- **API.md**: APIリファレンス
- **CHANGELOG.md**: 変更履歴

#### 8.2 CLAUDE.md固有の規約
プロジェクトごとのCLAUDE.mdには、以下の要素を含める：

- **関連ドキュメントへのリンク**: プロジェクトの重要なドキュメントへの参照
- **各ドキュメントの目次**: ドキュメントの内容を把握できる簡潔な目次
- **説明**: 各ドキュメントの役割と重要性の説明

例：
```markdown
## 関連ドキュメント

### @TECHNICAL_SPEC.md - 技術仕様書
- [概要](#概要) - システムの全体像
- [アーキテクチャ](#アーキテクチャ) - 設計方針
- [API仕様](#api仕様) - インターフェース定義
```

#### 8.3 レビュープロセス
- **技術的正確性**: 実装との整合性確認
- **読みやすさ**: 対象読者による理解度確認
- **完全性**: 必要な情報の網羅性確認
- **一貫性**: スタイルガイドへの準拠確認

これにより、CLAUDE.mdがプロジェクトのナビゲーションハブとして機能し、必要な情報に素早くアクセスできるようになります。

## Standard Directory Structure（標準ディレクトリ構造）

すべてのプロジェクトで以下の構造を維持：

```
<project-root>/
├── .tmp/               # 一時作業ディレクトリ（MUST be in .gitignore）
├── .claude/            # Claude関連の永続的な設定（optional）
├── CLAUDE.md           # 本ファイル
├── @Claude-Mistakes.md # インシデント記録
└── .gitignore          # 必須設定を含む
```

- **`.tmp/`**: すべての一時ファイル・スクリプトはここに作成
- **作業開始時**: `.tmp/` ディレクトリを作成（存在しない場合）
- **作業完了時**: `.tmp/` が空であることを確認

## Project structure

（起動時に正しいかどうか調査して変化があればユーザーに確認して修正を行う。）

- `/home/oomae`: ホームディレクトリ
- `/home/oomae/projects/`: 主要プロジェクトディレクトリ
- `/home/oomae/Tobishima/`: (プロジェクトの詳細を記載)
- `/home/oomae/work/`: 一時作業用ディレクトリ
- `/home/oomae/aws/`: AWS関連ディレクトリ
- `/.claude`: プロジェクト固有のClaudeコマンド用ディレクトリ
- `~/.claude/settings.json`: Claudeグローバル設定ファイル

## Standard .gitignore Template

すべてのプロジェクトで必須：

```gitignore
# Claude作業環境
.tmp/
*.tmp
*.temp

# Claudeシステムファイル（チーム環境では要検討）
# CLAUDE.md          # チームで共有する場合はコメントアウト
# @Claude-Mistakes.md # チームで共有する場合はコメントアウト
```

## Git workflow

### 戦略選択ガイド

プロジェクトの性質と規模に応じて、以下の4つの戦略から選択します：

#### 1. Trunk-Based Development（デフォルト推奨）
- **用途**: 日常的な開発、小規模な変更
- **特徴**:
  - mainブランチへ直接または短期ブランチ経由でマージ
  - ブランチ寿命: 最大2日
  - 頻繁な統合（1日複数回）
- **ブランチ命名**: `username/task-YYYYMMDD`
- **適用例**: バグ修正、小規模リファクタリング、ドキュメント更新

#### 2. GitHub Flow
- **用途**: 中規模の機能開発（1週間程度）
- **特徴**:
  - feature/*ブランチで開発
  - PRレビュー必須
  - mainへ直接マージ後、即デプロイ
- **ブランチ命名**: `feature/brief-description`
- **適用例**: 新機能追加、APIエンドポイント追加

#### 3. GitLab Flow / Release Flow
- **用途**: 環境別デプロイが必要なプロジェクト
- **特徴**:
  - 環境ブランチ: develop → staging → production
  - または: main → release/v1.0
- **ブランチ命名**: `release/v1.0.0`, `hotfix/issue-123`
- **適用例**: 複数環境管理、顧客別カスタマイズ

#### 4. Git Flow
- **用途**: 大規模製品リリース（使用は最小限に）
- **特徴**:
  - develop/mainの2本立て
  - 複雑なブランチ戦略
- **適用例**: メジャーバージョンリリース、破壊的変更

### 共通ルール

#### ブランチ命名規則
- **短期作業**: `username/description-YYYYMMDD`
- **機能開発**: `feature/issue-123-brief-description`
- **バグ修正**: `fix/issue-456-bug-description`
- **リファクタリング**: `refactor/target-component`
- **ドキュメント**: `docs/what-to-document`
- **リリース**: `release/v1.2.3`
- **ホットフィックス**: `hotfix/critical-issue`

#### コミットメッセージ規約
```
<type>(<scope>): <subject>

<body>

<footer>
```
- **type**: feat, fix, docs, style, refactor, test, chore
- **scope**: 影響範囲（オプション）
- **subject**: 50文字以内の要約
- **body**: 詳細説明（なぜこの変更が必要か）
- **footer**: Breaking changes, Closes #123など

例:
```
feat(auth): OAuth2.0認証を実装

GitHubとGoogleのOAuth認証をサポート。
既存のローカル認証と併用可能。

Closes #234
```

#### マージ戦略
- **Trunk-Based**: Fast-forward可能ならそのまま、不可ならrebase
- **GitHub Flow**: Squash mergeを推奨（履歴を整理）
- **GitLab Flow**: Merge commit（環境間の追跡のため）
- **Git Flow**: No fast-forward（--no-ff）

#### ブランチ保護ルール
- mainブランチへの直接push禁止（緊急時除く）
- 10コミット超えたらレビュー必須
- 3日以上のブランチは統合を検討
- CI/CDのパスが必須

#### プルリクエスト運用
- 作業開始時にDraft PR作成
- レビュー依頼前にセルフレビュー
- コンフリクトは作成者が解決
- 承認後は作成者がマージ

## Todo Management Guidelines

### TodoWrite活用の基本原則

1. **即時性**: タスクを認識したら即座にTodoWriteに記録
2. **単一進行**: `in_progress`は常に1つのみ
3. **即時完了**: タスク完了と同時に`completed`に更新

### TodoWrite必須化の条件

- **複雑なタスク**: 3つ以上のステップを含む作業
- **インシデント処理**: ミスやエラーが発生した場合
- **破壊的変更**: 既存の動作に影響を与える変更
- **新機能追加**: 新しい機能やモジュールの追加
- **大規模リファクタリング**: 複数ファイルにまたがる変更

### Todo優先度ガイドライン

- **critical**: システム停止、データ損失リスク、セキュリティ問題
- **high**: ユーザー指示の直接的な実装、インシデント処理
- **medium**: パフォーマンス改善、コード品質向上
- **low**: ドキュメント更新、スタイル修正

### Todoテンプレート

```markdown
# 複雑なタスク用
- [ ] [メインタスク名] (priority: high)
  - [ ] 事前調査・現状分析
  - [ ] 実装計画の作成
  - [ ] 実装作業
  - [ ] テスト作成・実行
  - [ ] ドキュメント更新
  - [ ] コミット作成

# インシデント処理用
- [ ] インシデント処理: [問題の概要] (priority: high)
  - [ ] @Claude-Mistakes.mdへの記録
  - [ ] 根本原因分析
  - [ ] 修正実装
  - [ ] 再発防止策の検討
  - [ ] CLAUDE.md更新案作成
```

### 一時ファイル管理との連携

- **複雑なタスク開始時のテンプレート**:
  ```markdown
  - [ ] [メインタスク名] (priority: high)
    - [ ] .tmp/ディレクトリ作成
    - [ ] 作業実施
    - [ ] .tmp/クリーンアップ
    - [ ] コミット作成
  ```
- **一時ファイル作成時**: 必ず対応する「クリーンアップ」サブタスクを追加
- **タスク完了チェック**: `.tmp/` が空であることを確認してからcompleted

## Project Initialization Checklist

新しいプロジェクトでCLAUDE.mdをコピーした際に自動実行：

```markdown
- [ ] CLAUDE.mdをプロジェクトルートにコピー (priority: high)
  - [ ] プロジェクト固有の設定を反映
  - [ ] Code styleセクションをプロジェクトに合わせて更新
  - [ ] 関連ドキュメントのリンクを追加
  - [ ] Git運用ルールとリンター設定の追記
- [ ] @Claude-Mistakes.mdファイルの作成 (priority: high)
- [ ] 標準ディレクトリ構造の確立 (priority: high)
  - [ ] .gitignoreに標準設定を追加
  - [ ] .tmp/ディレクトリの存在確認
  - [ ] Claudeシステムファイルの扱いを決定
- [ ] 初期Todo構造の設定 (priority: medium)
  - [ ] プロジェクトの主要タスクをTodoWriteに登録
  - [ ] マイルストーンの設定
- [ ] 初回コミット前の確認 (priority: high)  
  - [ ] .tmp/が空であることを確認
  - [ ] .gitignoreが正しく設定されていることを確認
- [ ] リンター初期設定 (priority: high)
  - [ ] 使用言語の検出（package.json, requirements.txt等）
  - [ ] .pre-commit-config.yamlの自動生成
  - [ ] pre-commit installの実行
  - [ ] 初回リンターチェック
```

---

@/home/oomae/typescript-setup-guide.md for TypeScript project setup
@package.json for available scripts (プロジェクト内に存在する場合)

---

## プロジェクトCLAUDE.mdへの追記テンプレート

以下をプロジェクトのCLAUDE.mdにコピーして、プロジェクトに合わせてカスタマイズしてください。

### プロジェクト固有のリンター設定

```yaml
# .pre-commit-config.yaml
repos:
  # JavaScript/TypeScript (プロジェクトでJS/TSを使用する場合)
  - repo: local
    hooks:
      - id: eslint
        name: ESLint
        entry: npx eslint --fix
        language: system
        files: \.(js|jsx|ts|tsx)$
        pass_filenames: true

  # Python (プロジェクトでPythonを使用する場合)
  - repo: https://github.com/astral-sh/ruff-pre-commit
    rev: v0.8.6
    hooks:
      - id: ruff
        args: [--fix]
      - id: ruff-format

  # Shell (プロジェクトでシェルスクリプトを使用する場合)
  - repo: https://github.com/shellcheck-py/shellcheck-py
    rev: v0.10.0.1
    hooks:
      - id: shellcheck
```

初回実行: `pre-commit install && pre-commit run --all-files`

### プロジェクト固有のGit運用
- メインブランチ: [main/master]
- コミット時の追加確認:
  - [ ] テストの実行
  - [ ] リンターのパス
  - [ ] ドキュメントの更新

---